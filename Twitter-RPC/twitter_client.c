/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "twitter.h"
#include "string.h"
#include <time.h>
#include <sys/timeb.h>  /* ftime, timeb (for timestamp in millisecond) */
#include <sys/time.h>   /* gettimeofday, timeval (for timestamp in microsecond) */
#include <postgresql/libpq-fe.h>	

post_users *post_user;


void retrieve_topic_prog_1(char *host, char usuario[20],char topic[40],char timestamp_req[80]){
	CLIENT *clnt;
	int  *result_1;
	int timestamp_tabela,timestamp_req_f;
	/* Variáveis para usar o banco de dados */
	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res;
	const char *paramValues[1];
	int paramLengths[1];
	int paramFormats[1];
	uint32_t binaryIntVal;

	timestamp_req_f = atoi(timestamp_req);
	printf("\n---------------- %d ---------------\n",timestamp_req_f);
	post_tweet_topic  post_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, RETRIEVE_TOPIC_PROG, RETRIEVE_TOPIC_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */

		/* INFO sobre o retorno de 'post_topic_' : 
			Quanto esta função é chamada, ele irá verificar se o tópico
			e o usuário solicitante existem no sistema.
			Caso existam, retornará uma struct contendo:
				@user = nome do usuário que criou o post -> para ver na hash os usuários que ele segue e enviar para todos
				@post = post escrito					 -> post que será usado para submeter a todos os usuários */
		result_1 = retrieve_topic_1(&post_1_arg, clnt);
		conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
		conn = PQconnectdb(conninfo); 
		
		if(PQstatus(conn) != CONNECTION_OK){	// Tenta conexão com banco de dados
			printf("Falha na conexão. Erro: %s", PQerrorMessage(conn));
			PQfinish(conn);
		}
		else{									// Caso a conexão esteja OK
			char query[5000];
			int i;
			sprintf(query,"SELECT * FROM topico_tabela WHERE topico_nome = '%s' AND post != ''",topic);
			res = PQexec(conn,query);
			if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
				printf("\n[RETRIEVE TOPICOS] - tempo requisitado : %d\n\n", timestamp_req_f);
				i = 0;
				printf("\n+------------------------%s------------------------------+\n\n",topic);
				for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
					timestamp_tabela = atoi( PQgetvalue(res,i,1));
					if(timestamp_tabela >= timestamp_req_f){
						printf("\n'%s' - %d",PQgetvalue(res,i,2),timestamp_tabela);
					}
				}
				printf("\n\n+-----------------------------------------------------------+\n\n");
			}

		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*	Lista os usuários cadastrados no twitter */
void list_topic_prog_1(char *host){
	CLIENT *clnt;
	int  *result_1;
	user_follow  follow_user_1_arg;

	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res;
	
	#ifndef	DEBUG
		clnt = clnt_create (host, LIST_TOPIC_PROG, LIST_TOPIC_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		result_1 = list_topic_1(&follow_user_1_arg,clnt);		// essa struct para o servidor
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
			conn = PQconnectdb(conninfo); 

			char query[500];
			sprintf(query,"SELECT DISTINCT topico_nome FROM topico_tabela WHERE topico_nome != ''");	
			res = PQexec(conn,query);
			printf("\n");
			if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
				printf("\n Tópicos cadastrados : \n\n");
				int i = 0;
				for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos tópicos para printá-los na tela
					printf("\n%d. %s",i+1,PQgetvalue(res,i,0));
				}
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/* Posta no twitter */
void post_tweet_prog_1(char *host, char usuario[20],char post[80]){
	CLIENT *clnt;
	int  *result_1;

	/* Variáveis para usar o banco de dados */
	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res;
	const char *paramValues[1];
	int paramLengths[1];
	int paramFormats[1];
	uint32_t binaryIntVal;

	post_tweet_topic  post_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, POST_TWEET_PROG, POST_TWEET_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(post_1_arg.topico,"");
		strcpy(post_1_arg.usuario,usuario);
		strcpy(post_1_arg.post,post);

		if(strlen(post) > 80){
			printf("\nDesculpe, a sua postagem excede 80 caractéres!\n\n");

		}else{
			/* INFO sobre o retorno de 'post_topic_' : 
				Quanto esta função é chamada, ele irá verificar se o tópico
				e o usuário solicitante existem no sistema.
				Caso existam, retornará uma struct contendo:
					@user = nome do usuário que criou o post -> para ver na hash os usuários que ele segue e enviar para todos
					@post = post escrito					 -> post que será usado para submeter a todos os usuários */
			post_user = post_tweet_1(&post_1_arg, clnt);
			
			conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
			conn = PQconnectdb(conninfo); 
			
			if(PQstatus(conn) != CONNECTION_OK){	// Tenta conexão com banco de dados
				printf("Falha na conexão. Erro: %s", PQerrorMessage(conn));
				PQfinish(conn);
			}
			else{									// Caso a conexão esteja OK
				char query[5000];
				int i;
				sprintf(query,"SELECT * FROM usuario_tabela WHERE usuario = '%s' AND usuario_follower != ''",post_user->user);
				res = PQexec(conn,query);
				if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
					printf("\n[VOCÊ TEM MENSAGENS NOVAS]\n\n");
					i = 0;
					printf("\n+-------------------------------------------------------+\n\n");
					for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
						printf("\n%s --> %s",PQgetvalue(res,i,2),post_user->post);
					}
					printf("\n\n+-----------------------------------------------------+\n\n");
				}

			}
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*  Posta um tópico */
void post_topic_prog_1(char *host, char usuario[20], char topico[40],char post[80]){
	CLIENT *clnt;
	int  *result_1;
	int timestamp;

	/* Variáveis 'timestamp' */
	time_t timestamp_sec;
  	time(&timestamp_sec);
	timestamp = timestamp_sec;
	// printf("\n\nTimestamp: %d\n",(int)time(NULL));
	// timestamp = (int) time (NULL);
	/* Variáveis para usar o banco de dados */
	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res;
	const char *paramValues[1];
	int paramLengths[1];
	int paramFormats[1];
	uint32_t binaryIntVal;

	post_tweet_topic  post_topic_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, POST_TOPIC_PROG, POST_TOPIC_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(post_topic_1_arg.topico,topico);
		strcpy(post_topic_1_arg.usuario,usuario);
		strcpy(post_topic_1_arg.post,post);
		post_topic_1_arg.timestamp = timestamp;

		if(strlen(post) > 80 ){
			printf("\nDesculpe, a sua postagem excede 80 caractéres!\n\n");
		}else{
			/* INFO sobre o retorno de 'post_topic_' : 
				Quanto esta função é chamada, ele irá verificar se o tópico
				e o usuário solicitante existem no sistema.
				Caso existam, retornará uma struct contendo:
					@user = nome do usuário que criou o post -> para ver na hash os usuários que ele segue e enviar para todos
					@post = post escrito					 -> post que será usado para submeter a todos os usuários */
			post_user = post_topic_1(&post_topic_1_arg, clnt);
			
			conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
			conn = PQconnectdb(conninfo); 
			
			if(PQstatus(conn) != CONNECTION_OK){	// Tenta conexão com banco de dados
				printf("Falha na conexão. Erro: %s", PQerrorMessage(conn));
				PQfinish(conn);
			}
			else{									// Caso a conexão esteja OK
				char query[5000];
				int i;
				sprintf(query,"SELECT * FROM usuario_tabela WHERE usuario = '%s' AND usuario_follower != ''",post_user->user);
				res = PQexec(conn,query);
				if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
					printf("\n[VOCÊ TEM NOVAS MENSAGENS] -> tempo de postagem : %d\n\n",(int) time (NULL));
					i = 0;
					printf("\n+-------------------------------------------------------+\n\n");
					for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
						printf("\n%s --> %s",PQgetvalue(res,i,2),post_user->post);
					}
					printf("\n\n+-----------------------------------------------------+\n\n");
				}

			}
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*	Cria um tópico	*/
void create_topic_prog_1(char *host, char usuario[20], char topico[40]){
	CLIENT *clnt;
	int  *result_1;
	post_tweet_topic  create_topic_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, CREATE_TOPIC_PROG, CREATE_TOPIC_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(create_topic_1_arg.topico,topico);
		strcpy(create_topic_1_arg.usuario,usuario);
		result_1 = create_topic_1(&create_topic_1_arg, clnt);
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			if(*result_1 == 1){
				printf("\nO tópico '%s' foi criado com sucesso!",topico);
			}else{
				printf("\nDesculpe, o tópico '%s' já está cadastrado no Twitter!\n",topico);
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*	Lista os usuários cadastrados no twitter */
void list_user_prog_1(char *host){
	CLIENT *clnt;
	int  *result_1;
	user_follow  follow_user_1_arg;

	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res;

	#ifndef	DEBUG
		clnt = clnt_create (host, LIST_USER_PROG, LIST_USER_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		result_1 = list_user_1(&follow_user_1_arg,clnt);		// essa struct para o servidor
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{

			conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
			conn = PQconnectdb(conninfo); 

			char query[500];
			sprintf(query,"SELECT DISTINCT usuario FROM usuario_tabela");	
			res = PQexec(conn,query);
			printf("\n");
			if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
				printf("\nUsuários cadastrados : \n\n");
				int i = 0;
				for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
					printf("\n%d. %s",i+1,PQgetvalue(res,i,0));
				}
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*	Deixa de seguir um usuário */
void unfollow_user_prog_1(char *host, char usuario[40],char usuario_seguir[40]){
	CLIENT *clnt;
	int  *result_1;
	user_follow  follow_user_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, UNFOLLOW_USER_PROG, UNFOLLOW_USER_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(follow_user_1_arg.user,usuario);					// Armazena o 'usuario' e 'usuario_a_seguir'
		strcpy(follow_user_1_arg.user_seguir,usuario_seguir);	// na struct 'user_follow' e envia
		result_1 = unfollow_user_1(&follow_user_1_arg, clnt);		// essa struct para o servidor
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			if(*result_1 == 1){
				printf("\nO usuario '%s' deixou de seguir '%s'!",usuario,usuario_seguir);
			}else if(*result_1 == 2){
				printf("\nOps! O usuário '%s' já não seguia '%s'!",usuario,usuario_seguir);
			}else{
				printf("\nDesculpe, o usuário algum dos usuários não está cadastrado no Twitter!\n");
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

/*	Segue um usuário */
void follow_user_prog_1(char *host, char usuario[40],char usuario_seguir[40]){
	CLIENT *clnt;
	int  *result_1;
	user_follow  follow_user_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, FOLLOW_USER_PROG, FOLLOW_USER_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(follow_user_1_arg.user,usuario);					// Armazena o 'usuario' e 'usuario_a_seguir'
		strcpy(follow_user_1_arg.user_seguir,usuario_seguir);	// na struct 'user_follow' e envia
		result_1 = follow_user_1(&follow_user_1_arg, clnt);		// essa struct para o servidor
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			if(*result_1 == 1){
				printf("\nO usuario '%s' agora segue '%s'!",usuario,usuario_seguir);
			}else if(*result_1 == 2){
				printf("\nOps! O usuário '%s' já segue o usuário '%s'!",usuario,usuario_seguir);
			}else{
				printf("\nDesculpe, o usuário algum dos usuários não está cadastrado no Twitter!\n");
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}
/*	Cria um usuário */
void create_user_prog_1(char *host, char usuario[20]){
	CLIENT *clnt;
	int  *result_1;
	tweet  create_user_1_arg;
	#ifndef	DEBUG
		clnt = clnt_create (host, CREATE_USER_PROG, CREATE_USER_VERS, "udp");
		if (clnt == NULL) {
			clnt_pcreateerror (host);
			exit (1);
		}
	#endif	/* DEBUG */
		strcpy(create_user_1_arg.usuario,usuario);
		result_1 = create_user_1(&create_user_1_arg, clnt);
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}else{
			if(*result_1 == 1){
				printf("\nO usuario '%s' foi criado com sucesso!",usuario);
			}else{
				printf("\nDesculpe, o usuário '%s' já está cadastrado no Twitter!\n",usuario);
			}
			printf("\n\n\n\n");
		}
	#ifndef	DEBUG
		clnt_destroy (clnt);
	#endif	 /* DEBUG */
}

void recebe_posts(char usuario[40]){
	const char *conninfo;
	PGconn *conn = NULL;
	PGresult *res,*res_2;

	conninfo = "dbname =rpc_banco host=localhost user=postgres password=nxfhep3d";
	conn = PQconnectdb(conninfo); 
	
	if(PQstatus(conn) != CONNECTION_OK){
		printf("Falha na conexão. Erro: %s", PQerrorMessage(conn));
        PQfinish(conn);
	}
	else{
		char query[500];
		char query_2[500], post[300];
		char user_av[40], topico_atual[40];
		int i,j;

		/* Pegando posts do comando TWEET ------------------------------------ */
			sprintf(query,"SELECT * FROM usuario_tabela WHERE  usuario_follower = '%s'",usuario);
			res = PQexec(conn,query);
			if(PQresultStatus(res) == PGRES_TUPLES_OK){	// Se tiver item na tabela
				i = 0;
				printf("\n+--- [VOCÊ TEM MENSAGENS NOVAS] --------------------+\n\n");
				for(i = 0 ; i < PQntuples(res); i++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
					if(strcmp(PQgetvalue(res,i,3),"") != 0)
						printf("\n%s --> %s",PQgetvalue(res,i,0),PQgetvalue(res,i,3));
				}
			}
		/* ------------------------------------------------------------------- */
		/* Pegando posts do comando POST_TOPIC-------------------------------- */
			sprintf(query,"SELECT * FROM topico_tabela");
			res = PQexec(conn,query);
			if(PQresultStatus(res) == PGRES_TUPLES_OK){	
				i = 0;
				for(i = 0 ; i < PQntuples(res); i++){
					strcpy(topico_atual,PQgetvalue(res,i,0));
					strcpy(user_av,PQgetvalue(res,i,3));	// Salva o nome do contato que criou o tópico para ver os usuários que o seguem e assim receberem a mensagem
					strcpy(post,PQgetvalue(res,i,2));		// Salva o tópico					
					sprintf(query_2,"SELECT * FROM usuario_tabela WHERE  usuario_follow = '%s' AND usuario='%s'",user_av,usuario);
					res_2 = PQexec(conn,query_2);

					if(PQresultStatus(res_2) == PGRES_TUPLES_OK){	// Se tiver item na tabela
						j = 0;
						for(j = 0 ; j < PQntuples(res_2); j++){	// Percorre a tabela, pegando o nome dos usuários para printá-los na tela
							if(strcmp(post,"") != 0)							
								printf("\n%s --> %s            Tópico : %s",user_av,post,topico_atual);
						}
					}
				}
				printf("\n\n+-----------------------------------------------------+\n\n");
			}
		/* ------------------------------------------------------------------- */
	}
}
int main (int argc, char *argv[]){
	char *host;
	char operacao[50],linha_operacao[50],usuario[40],usuario_seguir[40],post[5000],topico[40],timestamp[60];
	int op;
	int i,ind = 3,a;
	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	host = argv[1];				// Host
	strcpy(usuario,argv[2]); 	// Usuário a ser cadastrado


	printf("\n:: TWITTER ::\n\n");

	// Cada aplicação rodará para o usuário que for cadastrado em cada uma delas	
	create_user_prog_1(host,usuario);		// Criando um usuário

	while(1){								// Menu de informações

		// recebe_posts(usuario);
		printf("Seleciona a sua escolha : \n");
		printf("1. Seguir um usuário : \n");
		printf("2. Deixar de seguir um usuário : \n");
		printf("3. Tweetar : \n");
		printf("4. Criar um tópico (#) : \n");
		printf("5. Postar usando um tópico (#) : \n");
		printf("6. Recuperar postagens de um tópico : \n");
		printf("7. Listar usuários cadastrados : \n");
		printf("8. Listar tópicos cadastrados : \n\n");
		printf("9. Visualizar caixa de mensagens : \n\n");
		scanf("%d",&op);
		printf("\n\n\n\n");
		switch(op){
			case 1:		// Follow
				printf("\nDigite o nome do usuário que deseja seguir (utilize o @) :  ");
				scanf("%s",&usuario_seguir);
				follow_user_prog_1(host,usuario,usuario_seguir);
			break;
			case 2:		// Unfollow
				printf("\nDigite o nome do usuário que deseja parar de seguir (utilize o @) :  ");
				scanf("%s",&usuario_seguir);
				unfollow_user_prog_1(host,usuario,usuario_seguir);
			break;
			case 3:		// Tweet
				printf("\nDigite o seu post (máximo 180 caracteres) : \n");
				strcpy(post,"");
				scanf("%d",&a);
				scanf("%[^\n]s",post); 
				post_tweet_prog_1(host,usuario,post);
			break;
			case 4:		// Create topic
				printf("\nEscreva o nome do seu tópico (#) : \n");
				scanf("%s",topico); 
				create_topic_prog_1(host,usuario,topico);
			break;
			case 5:
				printf("\nDigite o nome do tópico (#) : \n");
				scanf("%s",topico);
				printf("\nDigite o seu post (máx 80 caracteres) :\n");
				strcpy(post,"");
				scanf("%d",&a);
				scanf("%[^\n]s",post); 
				post_topic_prog_1(host,usuario,topico,post);
			break;
			case 6:
				printf("\nDigite o tópico em que deseja resgatar as mensagens!\n");
				scanf("%s",topico);
				printf("\nDigite o timestamp : ");
				scanf("%s",timestamp);
				retrieve_topic_prog_1(host,usuario,topico,timestamp);
			break;
			case 7:
				list_user_prog_1(host);
			break;
			case 8:
				list_topic_prog_1(host);
			break;
			case 9:
				recebe_posts(usuario);
			break;
		}
	}






	/*
	strcpy(operacao,argv[2]);					// Copiamos o 2º argumento para a variável 'operacoes'  ->  ex: ./twitter_client localhost 'operacao_que_será_armazenada'
	while(argv[ind] != NULL){					// While responsável por pegar strings separadas por espaço em branco
		if(argv[ind] != NULL){
			strcat(operacao," ");
			strcat(operacao,argv[ind]);
		}
		ind++;
	}
	printf("\n\noperacao escrita : %s\n",operacao);
	op = identifica_operacao(operacao);			// Identifica qual operação o usuário inseriu
	// do{
		switch(op){
			case 1:
				parser_operacao(operacao,1,host);
			break;
			case 2:
				parser_operacao(operacao,2,host);
			break;
			case 3:
				parser_operacao(operacao,3,host);
			break;
			case 4:
				parser_operacao(operacao,4,host);
			break;
			case 5:
				parser_operacao(operacao,5,host);
			break;
			case 6:
				parser_operacao(operacao,6,host);
			break;
			case 7:
				parser_operacao(operacao,7,host);
			break;
			case 8:
				parser_operacao(operacao,8,host);
			break;
			case 9:
				parser_operacao(operacao,9,host);
			break;
		}
		printf("\n");
		*/
		// scanf("%s",operacao);
		// op = identifica_operacao(operacao);
	// } while(1 == 1);
	exit (0);
}
